//Libraries Imported Necessary to Run Equipment
#include <Servo.h>    
#include <Wire.h>
#include <LIDARLite.h>
#include <LiquidCrystal.h>
#include <XBee.h>
#include <SoftwareSerial.h>


//Software Serial Pinout
#define samples 110
SoftwareSerial outputSerial(10,9);

XBee xbee = XBee();
Rx16Response rx16 = Rx16Response();
int resetRSSI = -1000;    //The value that RSSI is reset to after each pass through filter
int temp, smoothData, rawData;
int timeToScan = 2000;
short currentHeading;
uint8_t currHeadingI2c[2];

//Structure to contain the readings from the beacon
struct{
  float heading;
  int signalStrength;
} readings[samples];

//Union for converting between byte[4] and float
union{
  float f;
  uint8_t b[4];
} heading_converter;


//Pin Out for Servo Pan-Tilt
#define tServo A0
#define bServo A2   

//Variables of Servo, Slave ID#
#define SLAVEID1 0x1
#define SLAVEID2 0x2

//Pan-Tilt Variables
Servo topServo;
Servo botServo;
LIDARLite Laser;

//Lidar Variables 
int posTT = 80;   //Top Servo Position
int posB = 0;     //Bottom Servo Position
int posBB = 180;  //Bottom Floor Sweep End Position
int posBL = 0;    //Bottom Left Stop Position
int posBM = 95;   //Bottom Midpoint Stop Position
int posTM = 80;   //Top Midpoint Stop Position

int scan = 15;   //Number of Laser Scans

char inByte;     //Variable for Receiving Command

const int rs = 12, en = 11, p1 = 5, p2 = 4, p3 = 3, p4 = 2;
LiquidCrystal lcd(rs, en, p1, p2, p3, p4);

unsigned long timer_1;  // Timer -> Screen
unsigned long timer_2;  // Timer -> Laser measurment
unsigned long timer_3;
unsigned long timer_4;

uint8_t delay_1 = 15; // Screeen delay
uint8_t delay_2 = 3; // Laser measurement

const uint8_t buffersize = 50;       // Size of the buffer for the laser
uint8_t _buffer[buffersize];  // Data structure to store data for averaging.
uint8_t pos = 0;              // Location in the buffer where the laser data will be stored
uint8_t avgdist = 0;          // Averaged distance

void setup() {
//  Serial.begin(9600);     //Serial Monitoring For Servo Troubleshooting
  Serial.begin(115200);   //Serial Monitoring For Lidar Troubleshooting
  mainSetup();
  delay(1000);
  timer_1 = millis();
  timer_2 = timer_1;
  timer_3 = timer_2;
  timer_4 = timer_3;
}

void loop() {
  unsigned long now = millis();
  if (now - timer_1 > delay_1) {
    writescreen((String)avgdist);
    printdata();
    timer_1 = now;
  }
  
  if (now - timer_2 > delay_2) {
    laserRead();
    timer_2 = now;
  }
}

///Function of Setup 
void mainSetup() {
  writescreen("Starting Setup");
  
  topServo.attach(tServo);
  delay(10);
  botServo.attach(bServo);
  delay(10);
  Laser.begin(0, true);
  delay(10);
  Wire.begin();
 /* Parameters
    ----------------------------------------------------------------------------
    configuration:  Default 0.
      0: Default mode, balanced performance.
      1: Short range, high speed. Uses 0x1d maximum acquisition count.
      2: Default range, higher speed short range. Turns on quick termination
          detection for faster measurements at short range (with decreased
          accuracy)
      3: Maximum range. Uses 0xff maximum acquisition count.
      4: High sensitivity detection. Overrides default valid measurement detection
          algorithm, and uses a threshold value for high sensitivity and noise.
      5: Low sensitivity detection. Overrides default valid measurement detection
          algorithm, and uses a threshold value for low sensitivity and noise.
    lidarliteAddress: Default 0x62. Fill in new address here if changed. See
      operating manual for instructions.
  */
  Laser.configure(0);
  delay(100);
  //XBee Setup
  Serial.begin(57600); 
  Serial1.begin(57600);
  xbee.setSerial(Serial1);
  outputSerial.begin(57600);

  //Initialize i2c communications
  Wire.begin(8);                // join i2c bus with address #8
  Wire.onRequest(i2cPrint); // register event
  Serial.println("Setup Complete");
  writescreen("Setup Completed");
}

void sendCommand(const int slaveid, const int dir){
  Wire.beginTransmission(slaveid); // transmit to device #8
  Wire.write(dir);              // sends one byte
  Wire.endTransmission(); 
}

void recCommand(int bytes){
  inByte = Wire.read();
}

void laserRead(){
    _buffer[pos++] = Laser.distance();
    if (pos > buffersize)
      pos = 0;
}

void writescreen(String data) {
  lcd.clear(); 
  lcd.begin(16,2);
  lcd.print(data);
}

void printdata() {
  String b = "Data:\t";
  float dataout = 0;
  for (int i = 0; i < buffersize; i++)
    dataout += _buffer[i];
  dataout /= buffersize;
  Serial.println((uint8_t)dataout);
  avgdist = dataout;
}
void Retrieve(int i){
  xbee.readPacket(10);    //Wait 50 to receive packet
  if (xbee.getResponse().isAvailable())     //Execute only if packet found
  {
    if (xbee.getResponse().getApiId() == RX_16_RESPONSE) 
    {
      xbee.getResponse().getRx16Response(rx16);
      //Store the transmitted data and RSSI
      for(int i = 0; i<4; i++) heading_converter.b[i] = rx16.getData(i);
      int currentRSSI = -rx16.getRssi();

      //Write to array
      readings[i].heading = heading_converter.f;
      readings[i].signalStrength = currentRSSI;
    }
  }else{
    readings[i].heading = 0;
    readings[i].signalStrength = resetRSSI;
  }
}
int ProcessData(){
  int maxRSSI;
  unsigned long maxIndex = 0;
  maxRSSI = readings[0].signalStrength;
  
  //Find max RSSI value
  for (int i=1; i < samples; i++) {
    if (maxRSSI < readings[i].signalStrength) {
      maxRSSI = readings[i].signalStrength;
      maxIndex = i;
    }
  }
  //If there is no valid data
  if(maxRSSI == resetRSSI){
    return -1;
  }

  float headingx = 0;
  float headingy = 0;
  for(int i = 0; i < samples; i++)
  {
    if (readings[i].signalStrength == -1000 && readings[i].heading == 0)
    {
       Serial.println("this heading not included");
    }
    else
    {
      Serial.print(readings[i].heading);
      Serial.print("\t");
      Serial.println(readings[i].signalStrength);
      // Set magnitude of vector by signal strength
      headingx += readings[i].signalStrength * cos(readings[i].heading * PI / 180);
      headingy += readings[i].signalStrength * sin(readings[i].heading * PI / 180);
    }
  }
  
  float heading = atan2(headingy, headingx);
  if (heading < 0) heading += 2 * PI;
  heading = heading * 180 / PI;

  return (int) heading;
}

//When info is requested over i2c
void i2cPrint()
{
  Wire.write(currHeadingI2c, 2);
  // as expected by master
}
void verticalSweep(int timer, int posTT) {
  for (posTT; posTT <= 180; posTT += 5) {
   Serial.print("(1)The position of Top is : ");
   Serial.print(posTT);
   Serial.print("  Movement Function: ");    
   Serial.println("Sweep Function");
   topServo.write(posTT);
    delay(timer);
  }
}

void horizontalSweep(int timer, int posB) {
  for (posB; posB <= 185; posB += 5) {
    Serial.print("(3)The position of Top is : ");
    Serial.print(posB);
    Serial.print("  Movement Function: ");
    Serial.println("Floor Sweep Function");
    botServo.write(posB);
    delay(timer);
  }
}

void midStop(int timer, int posBM) {
  Serial.print("(5)The position of Top is : ");
  Serial.print(posBM);
  Serial.print("  Movement Function: ");
  Serial.println("Mid-Stop Function.!");
  botServo.write(posBM);
  topServo.write(posTM);
  delay(timer);
  }

void botleftStop(int posBL, int timer){
  Serial.print("(6)The position of Top is : ");
  Serial.print(posBL);
  Serial.print("  Movement Function: ");
  Serial.println("Bottom Left Stop");
  botServo.write(posBL);
  delay(timer);
}
